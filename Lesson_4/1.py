from timeit import timeit
from functools import lru_cache
"""
1. Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках домашнего задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.
"""

"""
Найти сумму n элементов следующего ряда чисел: 1 -0.5 0.25 -0.125 ...
Количество элементов 100
"""


# Ряд чисел состоит из элементов, где каждый последующий меньше по модулю в 2 раза

k = 1
summ = 0
number = 100
l = 1

# Через цикл
'''Через цикл без кеширования получается самый быстрый способ подсчета суммы. Сложность алгоритма O(N).
После использования кеширования занимает 2 место по скорости работы. 
С использованием кеша алгоритм выполняеися с одинаковой скоростью вне зависимости от количества элементов 
последовательности и становится константным O(1)'''


@lru_cache()
def summa(summ, k):
    for n in range(number):
        summ += k
        k /= -2
    return summ


print(f'Сумма {number} элементов ряда: {summa(summ, k)}')

# Через список
'''Через список или через массив скорость в 1.7 раз медленнее чем при использовании цикла.
Это связано с тем что в начале создается пустой список(массив) и путем добавления формируется, а затем элементы списка
(массива) суммируются. В данном случае есть приемущество, если список(массив) будет использоваться повторно.
 Сложность алгоритма O(N). С использованием кеша алгоритм выбивается на 1 место и выполняется с одинаковой скоростью 
 вне зависимости от количества элементов последовательности и становится константным O(1)'''


@lru_cache()
def summa1(k):
    a = list() * number
    for i in range(number):
        a.append(k)
        k /= -2
    return sum(a)

# Через массив
# @lru_cache()
# def summa1(k):
#     a = [0] * number
#     for i in range(number):
#         a.append(k)
#         k /= -2
#     return sum(a)


print(f'Сумма {number} элементов ряда: {summa1(k)}')


# С рекурсией
'''Рекурсией расчет суммы происходит самым медленным способом и в 3 раза медленнее чем через цикл. Занимает 3 место
Это связано с событием вычисления текущего элемента путем вызова функции из самой себя, что существенно расходует 
время процессора и память на вычисления. С использованием кеша алгоритм выполняется с одинаковой скоростью 
 вне зависимости от количества элементов последовательности и становится константным O(1), но все равно выполняется 
 медленнее остальных и остается на 3 месте рейтинга'''


@lru_cache()
def summ_rec(k, l, number, summ):
    if k == number:
        return summ
    elif k < number:
        return summ_rec(k + 1, l / -2, number, summ + l)

# summ_cache_rec = {}
#
#
# def summ_rec(k, l, number, summ):
#     if summ in summ_cache_rec:
#         return summ_cache_rec[summ]
#     if k == number:
#         return summ
#     elif k < number:
#         value = summ_rec(k + 1, l / -2, number, summ + l)
#         summ_cache_rec[summ] = value
#         return value


print(f'Сумма {number} элементов ряда: {summ_rec(0, 1, number, 0)}')

print(timeit('summa(summ, k)', setup='from __main__ import summa, summ, k'))
print(timeit('summa1(k)', setup='from __main__ import summa1, k'))
print(timeit('summ_rec(k, l, number, summ)', setup='from __main__ import summ_rec, k, summ, number, l'))
